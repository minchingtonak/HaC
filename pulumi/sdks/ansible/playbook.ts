// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as utilities from "./utilities";

export class Playbook extends pulumi.CustomResource {
    /**
     * Get an existing Playbook resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: PlaybookState, opts?: pulumi.CustomResourceOptions): Playbook {
        return new Playbook(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'ansible:index/playbook:Playbook';

    /**
     * Returns true if the given object is an instance of Playbook.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is Playbook {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === Playbook.__pulumiType;
    }

    /**
     * Path to ansible-playbook executable (binary).
     */
    declare public readonly ansiblePlaybookBinary: pulumi.Output<string | undefined>;
    /**
     * An ansible-playbook CLI stderr output.
     */
    declare public /*out*/ readonly ansiblePlaybookStderr: pulumi.Output<string>;
    /**
     * An ansible-playbook CLI stdout output.
     */
    declare public /*out*/ readonly ansiblePlaybookStdout: pulumi.Output<string>;
    /**
     * Used to build arguments to run Ansible playbook with.
     */
    declare public /*out*/ readonly args: pulumi.Output<string[]>;
    /**
     * If 'true', playbook execution won't make any changes but only change predictions will be made.
     */
    declare public readonly checkMode: pulumi.Output<boolean | undefined>;
    /**
     * If 'true', when changing (small) files and templates, differences in those files will be shown. Recommended usage with
     * 'check_mode'.
     */
    declare public readonly diffMode: pulumi.Output<boolean | undefined>;
    /**
     * A map of additional variables as: { key-1 = value-1, key-2 = value-2, ... }.
     */
    declare public readonly extraVars: pulumi.Output<{[key: string]: string} | undefined>;
    /**
     * If 'true', run handlers even if a task fails.
     */
    declare public readonly forceHandlers: pulumi.Output<boolean | undefined>;
    /**
     * List of desired groups of hosts on which the playbook will be executed.
     */
    declare public readonly groups: pulumi.Output<string[] | undefined>;
    /**
     * This parameter is good for testing. Set to 'true' if the desired playbook is meant to fail, but still want the resource
     * to run successfully.
     */
    declare public readonly ignorePlaybookFailure: pulumi.Output<boolean | undefined>;
    /**
     * List of hosts to include in playbook execution.
     */
    declare public readonly limits: pulumi.Output<string[] | undefined>;
    /**
     * Name of the desired host on which the playbook will be executed.
     */
    declare public readonly name: pulumi.Output<string>;
    /**
     * Path to ansible playbook.
     */
    declare public readonly playbook: pulumi.Output<string>;
    declare public readonly playbookId: pulumi.Output<string>;
    declare public readonly replayable: pulumi.Output<boolean | undefined>;
    /**
     * List of tags of plays and tasks to run.
     */
    declare public readonly tags: pulumi.Output<string[] | undefined>;
    /**
     * Path to created temporary inventory file.
     */
    declare public /*out*/ readonly tempInventoryFile: pulumi.Output<string>;
    declare public readonly timeouts: pulumi.Output<outputs.PlaybookTimeouts | undefined>;
    /**
     * List of variable files.
     */
    declare public readonly varFiles: pulumi.Output<string[] | undefined>;
    /**
     * List of vault files.
     */
    declare public readonly vaultFiles: pulumi.Output<string[] | undefined>;
    /**
     * ID of the desired vault(s).
     */
    declare public readonly vaultId: pulumi.Output<string | undefined>;
    /**
     * Path to a vault password file.
     */
    declare public readonly vaultPasswordFile: pulumi.Output<string | undefined>;
    /**
     * A verbosity level between 0 and 6. Set ansible 'verbose' parameter, which causes Ansible to print more debug messages.
     * The higher the 'verbosity', the more debug details will be printed.
     */
    declare public readonly verbosity: pulumi.Output<number | undefined>;

    /**
     * Create a Playbook resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: PlaybookArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: PlaybookArgs | PlaybookState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as PlaybookState | undefined;
            resourceInputs["ansiblePlaybookBinary"] = state?.ansiblePlaybookBinary;
            resourceInputs["ansiblePlaybookStderr"] = state?.ansiblePlaybookStderr;
            resourceInputs["ansiblePlaybookStdout"] = state?.ansiblePlaybookStdout;
            resourceInputs["args"] = state?.args;
            resourceInputs["checkMode"] = state?.checkMode;
            resourceInputs["diffMode"] = state?.diffMode;
            resourceInputs["extraVars"] = state?.extraVars;
            resourceInputs["forceHandlers"] = state?.forceHandlers;
            resourceInputs["groups"] = state?.groups;
            resourceInputs["ignorePlaybookFailure"] = state?.ignorePlaybookFailure;
            resourceInputs["limits"] = state?.limits;
            resourceInputs["name"] = state?.name;
            resourceInputs["playbook"] = state?.playbook;
            resourceInputs["playbookId"] = state?.playbookId;
            resourceInputs["replayable"] = state?.replayable;
            resourceInputs["tags"] = state?.tags;
            resourceInputs["tempInventoryFile"] = state?.tempInventoryFile;
            resourceInputs["timeouts"] = state?.timeouts;
            resourceInputs["varFiles"] = state?.varFiles;
            resourceInputs["vaultFiles"] = state?.vaultFiles;
            resourceInputs["vaultId"] = state?.vaultId;
            resourceInputs["vaultPasswordFile"] = state?.vaultPasswordFile;
            resourceInputs["verbosity"] = state?.verbosity;
        } else {
            const args = argsOrState as PlaybookArgs | undefined;
            if (args?.playbook === undefined && !opts.urn) {
                throw new Error("Missing required property 'playbook'");
            }
            resourceInputs["ansiblePlaybookBinary"] = args?.ansiblePlaybookBinary;
            resourceInputs["checkMode"] = args?.checkMode;
            resourceInputs["diffMode"] = args?.diffMode;
            resourceInputs["extraVars"] = args?.extraVars;
            resourceInputs["forceHandlers"] = args?.forceHandlers;
            resourceInputs["groups"] = args?.groups;
            resourceInputs["ignorePlaybookFailure"] = args?.ignorePlaybookFailure;
            resourceInputs["limits"] = args?.limits;
            resourceInputs["name"] = args?.name;
            resourceInputs["playbook"] = args?.playbook;
            resourceInputs["playbookId"] = args?.playbookId;
            resourceInputs["replayable"] = args?.replayable;
            resourceInputs["tags"] = args?.tags;
            resourceInputs["timeouts"] = args?.timeouts;
            resourceInputs["varFiles"] = args?.varFiles;
            resourceInputs["vaultFiles"] = args?.vaultFiles;
            resourceInputs["vaultId"] = args?.vaultId;
            resourceInputs["vaultPasswordFile"] = args?.vaultPasswordFile;
            resourceInputs["verbosity"] = args?.verbosity;
            resourceInputs["ansiblePlaybookStderr"] = undefined /*out*/;
            resourceInputs["ansiblePlaybookStdout"] = undefined /*out*/;
            resourceInputs["args"] = undefined /*out*/;
            resourceInputs["tempInventoryFile"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(Playbook.__pulumiType, name, resourceInputs, opts, false /*dependency*/, utilities.getPackage());
    }
}

/**
 * Input properties used for looking up and filtering Playbook resources.
 */
export interface PlaybookState {
    /**
     * Path to ansible-playbook executable (binary).
     */
    ansiblePlaybookBinary?: pulumi.Input<string>;
    /**
     * An ansible-playbook CLI stderr output.
     */
    ansiblePlaybookStderr?: pulumi.Input<string>;
    /**
     * An ansible-playbook CLI stdout output.
     */
    ansiblePlaybookStdout?: pulumi.Input<string>;
    /**
     * Used to build arguments to run Ansible playbook with.
     */
    args?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * If 'true', playbook execution won't make any changes but only change predictions will be made.
     */
    checkMode?: pulumi.Input<boolean>;
    /**
     * If 'true', when changing (small) files and templates, differences in those files will be shown. Recommended usage with
     * 'check_mode'.
     */
    diffMode?: pulumi.Input<boolean>;
    /**
     * A map of additional variables as: { key-1 = value-1, key-2 = value-2, ... }.
     */
    extraVars?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * If 'true', run handlers even if a task fails.
     */
    forceHandlers?: pulumi.Input<boolean>;
    /**
     * List of desired groups of hosts on which the playbook will be executed.
     */
    groups?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * This parameter is good for testing. Set to 'true' if the desired playbook is meant to fail, but still want the resource
     * to run successfully.
     */
    ignorePlaybookFailure?: pulumi.Input<boolean>;
    /**
     * List of hosts to include in playbook execution.
     */
    limits?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Name of the desired host on which the playbook will be executed.
     */
    name?: pulumi.Input<string>;
    /**
     * Path to ansible playbook.
     */
    playbook?: pulumi.Input<string>;
    playbookId?: pulumi.Input<string>;
    replayable?: pulumi.Input<boolean>;
    /**
     * List of tags of plays and tasks to run.
     */
    tags?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Path to created temporary inventory file.
     */
    tempInventoryFile?: pulumi.Input<string>;
    timeouts?: pulumi.Input<inputs.PlaybookTimeouts>;
    /**
     * List of variable files.
     */
    varFiles?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * List of vault files.
     */
    vaultFiles?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * ID of the desired vault(s).
     */
    vaultId?: pulumi.Input<string>;
    /**
     * Path to a vault password file.
     */
    vaultPasswordFile?: pulumi.Input<string>;
    /**
     * A verbosity level between 0 and 6. Set ansible 'verbose' parameter, which causes Ansible to print more debug messages.
     * The higher the 'verbosity', the more debug details will be printed.
     */
    verbosity?: pulumi.Input<number>;
}

/**
 * The set of arguments for constructing a Playbook resource.
 */
export interface PlaybookArgs {
    /**
     * Path to ansible-playbook executable (binary).
     */
    ansiblePlaybookBinary?: pulumi.Input<string>;
    /**
     * If 'true', playbook execution won't make any changes but only change predictions will be made.
     */
    checkMode?: pulumi.Input<boolean>;
    /**
     * If 'true', when changing (small) files and templates, differences in those files will be shown. Recommended usage with
     * 'check_mode'.
     */
    diffMode?: pulumi.Input<boolean>;
    /**
     * A map of additional variables as: { key-1 = value-1, key-2 = value-2, ... }.
     */
    extraVars?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * If 'true', run handlers even if a task fails.
     */
    forceHandlers?: pulumi.Input<boolean>;
    /**
     * List of desired groups of hosts on which the playbook will be executed.
     */
    groups?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * This parameter is good for testing. Set to 'true' if the desired playbook is meant to fail, but still want the resource
     * to run successfully.
     */
    ignorePlaybookFailure?: pulumi.Input<boolean>;
    /**
     * List of hosts to include in playbook execution.
     */
    limits?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Name of the desired host on which the playbook will be executed.
     */
    name?: pulumi.Input<string>;
    /**
     * Path to ansible playbook.
     */
    playbook: pulumi.Input<string>;
    playbookId?: pulumi.Input<string>;
    replayable?: pulumi.Input<boolean>;
    /**
     * List of tags of plays and tasks to run.
     */
    tags?: pulumi.Input<pulumi.Input<string>[]>;
    timeouts?: pulumi.Input<inputs.PlaybookTimeouts>;
    /**
     * List of variable files.
     */
    varFiles?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * List of vault files.
     */
    vaultFiles?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * ID of the desired vault(s).
     */
    vaultId?: pulumi.Input<string>;
    /**
     * Path to a vault password file.
     */
    vaultPasswordFile?: pulumi.Input<string>;
    /**
     * A verbosity level between 0 and 6. Set ansible 'verbose' parameter, which causes Ansible to print more debug messages.
     * The higher the 'verbosity', the more debug details will be printed.
     */
    verbosity?: pulumi.Input<number>;
}
